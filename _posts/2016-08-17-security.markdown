---
title: Security
layout: post
date: 2016-08-17 16:40:45
description: |
    To authenticate with my server, you will need to sign in to my server with your email and a password. They will both be encrypted with powerful **AES encryption**. Not only this, but the password will also be **hashed** and **salted** underneath that heavy encryption. Also, every single packet that goes between you and the server will be AES encrypted.
---

I take security very seriously. Here I shall outline the various measures that I will be taking to ensure a secure system.

## Authenticating With My Server
To authenticate with my server, you will need to sign in to my server with your email and a password. They will both be encrypted with powerful **AES encryption**. Not only this, but the password will also be **hashed** and **salted** underneath that heavy encryption.

**Hashing** is when you use a complex algorithm to crush down the bytes (1s and 0s) of a password into a string of what looks like random characters. This is called the hash. If a single character in your password is different, the hash will be *completely* different. But if you don't change anything, then the hash result will always be *exactly* the same every time. Also, it is almost impossible to get the original password from a hash. What my server will do is that it will store the *hash* of your password rather than your actual password. When you submit the password to my server, the password you typed in will not be sent to my server. Instead, it will be hashed and the *hash* will be sent to my server. If the hash matches the hash that is in my server's database then I would know that the password is correct - and I could know this without ever knowing the actual password. This also means that if my database ever gets leaked, all that the hackers will find is a jumble of seemingly meaningless letters.

**Salting** takes this hashing concept to the next level. Let's say that someone got hands on one of the hashes in my database. They can try to **brute force** or **dictionary attack** that hash. **Brute forcing** is when you hash every combination of letters and see if it matches the hash in the database until you finally find the password. Understandably, this will take a long, long amount of time and so it is only good for passwords that are only a couple of characters long. If your password is a decent size, then it will take centuries to finally get the password. Most hackers wouldn't even think of attempting this.

A **dictionary attack** is when a hacker uses a word list - such as a dictionary or a list of the most commonly used passwords or something - and they run through the list, trying everything in the list against the hash. They might even do all sorts of fancy stuff like joining several items in the word list together, adding letters and numbers after the entries in the wordlist and shifting case, etc. Of course, in both brute forcing and dictionary attacks, the fact that the hacker needs to compute a hash at every attempt at getting the password will slow down the hacker to the point where finding the password would take decades if you have a decent password. However, when it comes to dictionary attacks, there are what is known as **rainbow tables**. A rainbow table is basically a wordlist and next to each wordlist is the pre-computed hash corresponding to that entry. This way, it is much faster.

***AND THIS*** is where **salting** comes in. **Salting** is when you get a long random string of letters and prepend it to the password before you hash the password. You also keep the random string of letters in plain text next to the hash in the database. You could write the salt on a piece of paper and shove it in the hacker's face for all it matters. Either way, nobody is going to have made a rainbow table which has precomputed all the entries in a wordlist - but with this specific string of random letters at the start. This means that the hacker is going to have to resort to computing all the hashes himself and, again, this will take him absolutely decades.

Oh, you thought I was finished there? The whole thing (the hash and the email, etc) is going to also be encrypted with the insanely secure AES encryption. AES encryption is a symmetric encryption method. This means it needs a key - a secret password to encrypt or decrypt data. This key is going to be randomly generated each time a client connects to the server, the key is given to the client and from then onwards, <del>everything - the packets,</del> the authentication data<del>, etc - </del> is going to be encrypted using the key.

"But surely a hacker could intercept the key!?" I hear you say. However, fear not! Obviously the key is not going to be sent in plain text. I am going to use a special protocol to send the AES Key, which uses RSA. RSA is an asymmetric algorithm. That means that there are two types of keys, a public key and a private key. Here's my analogy for this protocol:

> Let's say I have a box that has a special kind of lock. The keyhole on the box can either be locked by turning it to the left or turning it to the right. When it is not locked, it is vertical. If it is not locked, then it has been turned either to the left or to the right. This lock also has two different keys. A public key and a private key. The public key is public. I make copies of it and distribute it to all of my friends. The private key, however, I keep to myself. The public key can only turn clockwise and the private key can only turn anticlockwise. To encrypt something with the public key, you put something in the box and lock the lock by turning it clockwise. You then send this box to me. I can use my private key to unlock the box by turning the lock anticlockwise and get to the thing in the box. So that means that everyone I gave a public key to can securely send me stuff using this box. Also, this means that if I lock something in my box using my private key, anyone with a public key would be able to unlock the thing in the box. However, this is more useful than it seems because since only the public key I gave out can work with my private key, anyone who gets the box and can unlock it with my public key can be sure that the person who locked the box locked it with my private key. Since I kept my private key only to myself, if you can unlock the box with my public key, you can be pretty sure that I was the person that locked it. This is called signing.

By the way, if you want to see the actual maths behind it then you can probably find something interesting on the Internet. Now here is how the protocol works.

Ok now let me explain this key exchange protocol using this analogy:

> The server has a public key and a private key. The server sends its public key directly to the client. The client has one of those special boxes, a public key and a private key. The client puts the public key to his box inside of his box and then locks the box with the server's public key that he just received. He then sends this locked box back to the server. Now since the server has the corresponding private key to the public key that locked the box (his public key), it can easily unlock the box and take out the client's public key. Now the server puts inside the box the AES Key and locks it with the client's public key which he just took out of the box. The server sends the locked box back to the client and the client can unlock the box with his private key. There we have it, the AES key was exchanged without the private keys ever been sent. If anyone was intercepting the things they were sending to each other, all that they would have received is firstly, the server's public key. Secondly, the client's box with the client's public key inside of it locked with the server's public key. And thirdly, the box being returned to the client from the server with the AES Key inside of it, locked with the client's public key. There is absolutely no way for him to open any of the boxes at any stage.

This is what will happen when you try and authenticate to my server. The public keys, the private keys and the AES Key will be regenerated per session. At the same time that this protocol is happening, the server will also make use of signing with persistent keys to validify if the client is legit.

## What about my ROTMG Login Details?
You may or may not know already but the ROTMG authentication packet, i.e the HELLO packet, will have your GUID (E-Mail) and your password. However, they are both RSA encrypted with the ROTMG's public key. This means that no matter what I do, I cannot see your email or your password because I do not have ROTMG's private key. Admittedly, I can still send this hello packet to the ROTMG servers and try to login with your account, however, if ROTMG change their keys (and they sometimes do), I won't be able to do that anymore. Either way, I am not going to store the hello packet anywhere and I will never go on your account without your express permission. You do need to trust me a little bit on this one, but please understand that even if I did have malicious intentions with the HELLO packets, the things I could do would be very limited. This is something that is unavoidable. I suppose you have to just let the results of the program speak for itself and have faith in that. If it makes you feel more assured, please do change your ROTMG password or make an account to only fame train with or something.

## TL;DR
No one's getting your sensitive information any time soon.